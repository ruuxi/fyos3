import { convertToModelMessages, streamText, UIMessage, stepCountIs, tool } from 'ai';
import { z } from 'zod';

export const maxDuration = 30;

export async function POST(req: Request) {
  const { messages }: { messages: UIMessage[] } = await req.json();

  const result = streamText({
    model: 'anthropic/claude-sonnet-4',
    messages: convertToModelMessages(messages),
    stopWhen: stepCountIs(8),
    system:
      [
        'You are a proactive engineering agent operating inside a WebContainer-powered workspace.',
        'You can read and modify files, create apps, and run package installs/commands.',
        'Always follow this loop: 1) find files 2) plan 3) execute 4) report.',
        'Prefer minimal changes. Keep changes focused and consistent with the codebase.',
        'Project is a Vite React app with: source in src/, public files in public/.',
        'When creating apps: place code in src/apps/<id>/index.tsx and update public/apps/registry.json with path /src/apps/<id>/index.tsx.'
      ].join(' '),
    tools: {
      // Step 1 – file discovery
      web_fs_find: {
        description: 'List files and folders recursively within the WebContainer workdir.',
        inputSchema: z.object({
          root: z.string().default('.').describe('Root path to start listing'),
          maxDepth: z.number().min(0).max(20).default(10),
        }),
      },
      // File reads
      web_fs_read: {
        description: 'Read a file from the WebContainer filesystem.',
        inputSchema: z.object({
          path: z.string().describe('Absolute or relative file path'),
          encoding: z.enum(['utf-8', 'base64']).optional().default('utf-8'),
        }),
      },
      // Writes and mkdirs
      web_fs_write: {
        description: 'Write file contents to a path. Creates folders if needed.',
        inputSchema: z.object({
          path: z.string(),
          content: z.string().describe('Full new file content'),
          createDirs: z.boolean().optional().default(true),
        }),
      },
      web_fs_mkdir: {
        description: 'Create a directory (optionally recursive).',
        inputSchema: z.object({
          path: z.string(),
          recursive: z.boolean().optional().default(true),
        }),
      },
      web_fs_rm: {
        description: 'Remove a file or directory (recursive by default).',
        inputSchema: z.object({
          path: z.string(),
          recursive: z.boolean().optional().default(true),
        }),
      },
      // Process execution
      web_exec: {
        description:
          'Run a command in the WebContainer (e.g. pnpm add <pkg>, pnpm run build).',
        inputSchema: z.object({
          command: z.string(),
          args: z.array(z.string()).optional().default([]),
          cwd: z.string().optional(),
        }),
      },
      // High-level: create app folder structure with auto-generated id
      create_app: {
        description:
          'Create a new app in apps/<uuid> with metadata and an optional icon. The id is generated by code.',
        inputSchema: z.object({
          name: z.string().describe('Display name of the app'),
          icon: z.string().optional().describe('Icon character or SVG string'),
        }),
      },
      // Update registry: rename an app by id
      rename_app: {
        description: 'Rename an app in registry.json by id (does not change id or folder).',
        inputSchema: z.object({
          id: z.string().describe('App id to rename'),
          name: z.string().describe('New display name'),
        }),
      },
      // Remove an app from disk and registry
      remove_app: {
        description: 'Remove an app from apps/<id> (or app-<id>) and registry.json by id.',
        inputSchema: z.object({
          id: z.string().describe('App id to remove'),
        }),
      },
      // Planning helper – capture a plan before execution
      submit_plan: tool({
        description: 'Submit a structured execution plan before making changes.',
        inputSchema: z.object({ steps: z.array(z.string()) }),
        async execute({ steps }) {
          return { accepted: true, steps };
        },
      }),
    },
  });

  return result.toUIMessageStreamResponse();
}
