<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>App</title>
    <style>
      html,body,#mount{height:100%;margin:0}
      /* Ensure scrolling happens inside the app mount, not the iframe viewport */
      #mount{overflow:auto;-webkit-overflow-scrolling:touch;overscroll-behavior:contain}
      body{background:#0b1020;overflow:hidden}
      #vite-hmr-mask{position:fixed;inset:0;pointer-events:none;opacity:0;transition:opacity .16s ease;z-index:2147483646;background:rgba(5,8,18,.78);backdrop-filter:blur(6px)}
      #vite-hmr-mask.active{opacity:1}
      #vite-hmr-mask[data-mode="error"]{background:rgba(35,4,12,.85)}
      #vite-hmr-mask[data-mode="agent"]{background:rgba(4,10,24,.82)}
      #vite-hmr-mask[data-mode="hmr"]{background:rgba(2,6,18,.74)}
      #vite-hmr-mask[data-mode="boot"]{background:rgba(2,6,18,.74)}
      #vite-hmr-mask [data-hmr-snapshot]{width:100%;height:100%;pointer-events:none;opacity:.97;filter:saturate(.92)}
    </style>
  </head>
  <body>
    <div id="mount" style="height:100%"></div>
    <div id="vite-hmr-mask" style="position:fixed;inset:0;background:#0b1020;opacity:0;pointer-events:none;transition:opacity .12s ease;z-index:2147483646"></div>
    <script type="module">
      class SnapshotMask {
        constructor(getRoot) {
          this.getRoot = getRoot;
          this.overlay = document.getElementById('vite-hmr-mask');
          if (this.overlay) {
            this.overlay.classList.add('hmr-mask');
          }
          this.hideTimer = null;
          this.pinned = null;
        }
        getRootNode() {
          try {
            return typeof this.getRoot === 'function' ? this.getRoot() : null;
          } catch {
            return null;
          }
        }
        takeSnapshot() {
          if (!this.overlay) return;
          const root = this.getRootNode();
          if (!root) return;
          const clone = root.cloneNode(true);
          clone.setAttribute('aria-hidden', 'true');
          clone.setAttribute('data-hmr-snapshot', 'true');
          const scripts = clone.querySelectorAll('script');
          scripts.forEach((node) => {
            try { node.remove(); } catch {}
          });
          this.overlay.replaceChildren(clone);
        }
        show(mode) {
          if (!this.overlay) return;
          this.takeSnapshot();
          if (mode) this.overlay.dataset.mode = mode;
          this.overlay.classList.add('active');
        }
        flash(mode) {
          if (this.pinned) {
            this.takeSnapshot();
            return;
          }
          this.show(mode || 'hmr');
          this.scheduleHide();
        }
        pin(mode) {
          this.pinned = mode || 'hmr';
          this.show(this.pinned);
        }
        unpin(mode) {
          if (mode && this.pinned && this.pinned !== mode) return;
          this.pinned = null;
          this.clear();
        }
        scheduleHide() {
          if (!this.overlay) return;
          if (this.hideTimer) window.clearTimeout(this.hideTimer);
          this.hideTimer = window.setTimeout(() => {
            if (!this.pinned) {
              this.clear();
            }
          }, 160);
        }
        clear() {
          if (!this.overlay) return;
          this.overlay.classList.remove('active');
          this.overlay.dataset.mode = '';
          if (this.overlay.childNodes.length) {
            this.overlay.replaceChildren();
          }
        }
      }
      const hmrMask = new SnapshotMask(() => document.getElementById('mount'));

      window.addEventListener('message', (event) => {
        const payload = event.data;
        if (!payload || typeof payload !== 'object') return;
        const type = payload.type;
        if (type === 'FYOS_MASK_PIN') {
          const mode = typeof payload.mode === 'string' ? payload.mode : 'hmr';
          hmrMask.pin(mode);
          return;
        }
        if (type === 'FYOS_MASK_UNPIN') {
          const mode = typeof payload.mode === 'string' ? payload.mode : undefined;
          hmrMask.unpin(mode);
          return;
        }
        if (type === 'FYOS_MASK_FLASH') {
          const mode = typeof payload.mode === 'string' ? payload.mode : 'hmr';
          hmrMask.flash(mode);
        }
      });

      const announceBuildEvent = (type, payload) => {
        try {
          const target = window.top || window.parent;
          if (!target) return;
          if (type === 'APP_BUILD_ERROR') {
            const detail = (payload && payload.err) ? payload.err : (payload || {});
            target.postMessage({
              type,
              message: detail.message || 'Unknown build error',
              stack: detail.stack || '',
              plugin: detail.plugin || '',
              id: detail.id || '',
              frame: detail.frame || '',
              pathname: location.pathname,
              search: location.search,
              hash: location.hash,
              scope: 'app',
              timestamp: Date.now()
            }, '*');
          } else {
            target.postMessage({
              type,
              pathname: location.pathname,
              search: location.search,
              hash: location.hash,
              scope: 'app',
              timestamp: Date.now()
            }, '*');
          }
        } catch {}
      };

      let suppressErrorsUntil = 0;
      // Disable Vite error overlay in iframe and forward diagnostics upstream
      if (import.meta.hot) {
        import.meta.hot.on('vite:error', (payload) => {
          console.error('[App iframe] Vite error:', payload);
          hmrMask.pin('error');
          announceBuildEvent('APP_BUILD_ERROR', payload);
        });
        import.meta.hot.on('vite:beforeUpdate', () => {
          suppressErrorsUntil = Date.now() + 1500;
          hmrMask.flash();
        });
        import.meta.hot.on('vite:afterUpdate', () => {
          hmrMask.unpin('error');
          hmrMask.flash();
          announceBuildEvent('APP_BUILD_ERROR_CLEARED');
        });
        import.meta.hot.on('full-reload', () => {
          hmrMask.pin('reload');
        });
      }
      
      // Block vite-error-overlay custom element
      const originalDefine = customElements.define;
      customElements.define = function(name, constructor, options) {
        if (name === 'vite-error-overlay') {
          console.log('[App iframe] Blocked vite-error-overlay');
          return;
        }
        return originalDefine.call(this, name, constructor, options);
      };

      // Watch for and remove any vite-error-overlay elements
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeName === 'VITE-ERROR-OVERLAY' || 
                (node.tagName && node.tagName.toLowerCase() === 'vite-error-overlay')) {
              console.log('[App iframe] Removing vite-error-overlay');
              node.remove();
            }
          });
        });
      });
      observer.observe(document.body, { childList: true, subtree: true });

      // No agent-run masking: HMR updates flow normally without pausing

      // Immediately isolate this iframe from parent errors
      window.addEventListener('error', (e) => {
        if (Date.now() < suppressErrorsUntil) return;
        e.stopPropagation();
        e.preventDefault();
        console.error('[App iframe] window error:', e.error || e.message);
        showOverlay(String(e?.error?.message || e?.message || 'Unknown error'));
        // Forward runtime error to host for automatic diagnostics
        try {
          window.top?.postMessage({
            type: 'APP_RUNTIME_ERROR',
            message: String(e?.error?.message || e?.message || 'Unknown error'),
            stack: String((e?.error && e.error.stack) || ''),
            pathname: location.pathname,
            search: location.search,
            hash: location.hash
          }, '*');
        } catch {}
      }, true);
      
      window.addEventListener('unhandledrejection', (e) => {
        if (Date.now() < suppressErrorsUntil) return;
        e.stopPropagation();
        e.preventDefault();
        console.error('[App iframe] unhandledrejection:', e.reason);
        showOverlay(String(e?.reason?.message || e?.reason || 'Unhandled promise rejection'));
        // Forward promise rejection to host for automatic diagnostics
        try {
          window.top?.postMessage({
            type: 'APP_RUNTIME_ERROR',
            message: String(e?.reason?.message || e?.reason || 'Unhandled promise rejection'),
            stack: String((e?.reason && e.reason.stack) || ''),
            pathname: location.pathname,
            search: location.search,
            hash: location.hash
          }, '*');
        } catch {}
      }, true);

      // Prevent errors from bubbling to parent
      const originalConsoleError = console.error;
      console.error = function(...args) {
        try {
          originalConsoleError.apply(console, ['[App iframe]', ...args]);
        } catch {}
        // Forward to host for automatic diagnostics
        try {
          const safeArgs = args.map(a => {
            try {
              if (typeof a === 'string') return a;
              if (a && typeof a === 'object') return a.message || JSON.stringify(a).slice(0, 1200);
              return String(a);
            } catch { return '[unserializable]'; }
          });
          window.top?.postMessage({
            type: 'APP_CONSOLE',
            level: 'error',
            args: safeArgs,
            pathname: location.pathname,
            search: location.search,
            hash: location.hash
          }, '*');
        } catch {}
      };

      // Also forward console.warn (lower priority; host may ignore)
      const originalConsoleWarn = console.warn;
      console.warn = function(...args) {
        try { originalConsoleWarn.apply(console, ['[App iframe]', ...args]); } catch {}
        try {
          const safeArgs = args.map(a => {
            try {
              if (typeof a === 'string') return a;
              if (a && typeof a === 'object') return a.message || JSON.stringify(a).slice(0, 800);
              return String(a);
            } catch { return '[unserializable]'; }
          });
          window.top?.postMessage({
            type: 'APP_CONSOLE',
            level: 'warn',
            args: safeArgs,
            pathname: location.pathname,
            search: location.search,
            hash: location.hash
          }, '*');
        } catch {}
      };


      let contextPointerActive = false;
      let contextPointerId = null;

      const sendContextPointer = (phase, evt) => {
        try {
          const frame = window.frameElement;
          if (!frame) return;
          const rect = frame.getBoundingClientRect();
          const appId = frame.getAttribute('data-app-id') || null;
          window.parent?.postMessage({
            type: 'FYOS_DESKTOP_CONTEXT_POINTER',
            phase,
            pointerId: evt.pointerId,
            clientX: rect.left + evt.clientX,
            clientY: rect.top + evt.clientY,
            button: evt.button,
            buttons: evt.buttons,
            pointerType: evt.pointerType,
            appId,
          }, '*');
        } catch {}
      };

      window.addEventListener('contextmenu', (evt) => {
        evt.preventDefault();
      });

      window.addEventListener('pointerdown', (evt) => {
        if (evt.button !== 2) return;
        contextPointerActive = true;
        contextPointerId = evt.pointerId;
        try { evt.target?.setPointerCapture?.(evt.pointerId); } catch {}
        evt.preventDefault();
        evt.stopPropagation();
        sendContextPointer('down', evt);
      }, true);

      window.addEventListener('pointermove', (evt) => {
        if (!contextPointerActive || contextPointerId !== evt.pointerId) return;
        evt.preventDefault();
        sendContextPointer('move', evt);
      }, true);

      const finalizeContextPointer = (phase, evt) => {
        if (!contextPointerActive || contextPointerId !== evt.pointerId) return;
        evt.preventDefault();
        sendContextPointer(phase, evt);
        try { evt.target?.releasePointerCapture?.(evt.pointerId); } catch {}
        contextPointerActive = false;
        contextPointerId = null;
      };

      window.addEventListener('pointerup', (evt) => finalizeContextPointer('up', evt), true);
      window.addEventListener('pointercancel', (evt) => finalizeContextPointer('cancel', evt), true);

      
      import { createRoot } from '/src/iframe-root.js';
      const loaders = import.meta.glob('/src/apps/**/index.{tsx,ts,jsx,js}');
      // Expect query: ?path=/src/apps/xxx/index.tsx&name=...&id=...
      const params = new URLSearchParams(location.search)
      const path = params.get('path')
      const name = params.get('name') || 'App'
      const mountEl = document.getElementById('mount')
      
      // Import CSS for styling (always load; URL flags can disable if set to 0)
      // Flag: ui=0 (disable desktop chrome)
      try {
        const loadUi = params.get('ui') !== '0'
        if (loadUi) {
          await import('/src/desktop/styles.css')
          console.log('[App iframe] Desktop UI CSS loaded')
        }
      } catch (e) {
        console.error('[App iframe] CSS import error:', e)
      }
      
      // Global error isolation inside iframe
      const overlay = document.createElement('div')
      overlay.style.cssText = 'position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(255,255,255,0.85);color:#991b1b;text-align:center;z-index:99999;padding:16px'
      overlay.innerHTML = '<div style="max-width:560px"><div style="font-weight:600;margin-bottom:6px">This app encountered an error</div><div id="errMsg" style="font-size:12px;color:#7f1d1d;white-space:pre-wrap"></div><button id="reloadBtn" style="margin-top:12px;padding:6px 10px;border-radius:6px;border:1px solid #fecaca;background:#fee2e2;color:#7f1d1d">Reload app</button></div>'
      document.body.appendChild(overlay)
      overlay.querySelector('#reloadBtn')?.addEventListener('click', ()=> location.reload())
      
      function showOverlay(msg){
        const el = overlay.querySelector('#errMsg')
        if (el) el.textContent = msg
        overlay.style.display = 'flex'
      }
      if (!path){
        mountEl.textContent = 'Missing app path'
      } else {
        // Wrap everything in try-catch to prevent errors from bubbling up
        try {
          // Load the module and mount default export as a React component
          const load = loaders[path] ? loaders[path] : (p)=> import(/* @vite-ignore */ p);
          Promise.resolve(load(path)).then(mod => {
            try {
              const Comp = mod?.default
              createRoot(mountEl, Comp, name)
            } catch (renderErr) {
              console.error('[App iframe] component render error:', renderErr)
              showOverlay('App render error: ' + renderErr.message)
            }
          }).catch(err => {
            console.error('[App iframe] module load error:', err)
            showOverlay('Failed to load app: ' + err)
          })
        } catch (err) {
          console.error('[App iframe] setup error:', err)
          showOverlay('App setup error: ' + err)
        }
      }
    </script>
  </body>
  </html>
