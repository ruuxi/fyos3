<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>App</title>
    <style>
      html,body,#mount{height:100%;margin:0}
      /* Ensure scrolling happens inside the app mount, not the iframe viewport */
      #mount{overflow:auto;-webkit-overflow-scrolling:touch;overscroll-behavior:contain}
      body{background:#0b1020;overflow:hidden}
    </style>
    <!-- Preload Tailwind CSS to ensure it's available immediately -->
    <link rel="preload" href="/src/tailwind.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/src/tailwind.css"></noscript>
  </head>
  <body>
    <div id="mount" style="height:100%"></div>
    <div id="vite-hmr-mask" style="position:fixed;inset:0;background:#0b1020;opacity:0;pointer-events:none;transition:opacity .12s ease;z-index:2147483646"></div>
    <script type="module">
      // Disable Vite error overlay in iframe
      if (import.meta.hot) {
        import.meta.hot.on('vite:error', (payload) => {
          // Prevent Vite error overlay from showing
          console.error('[App iframe] Vite error:', payload);
        });
        
      }
      
      // Block vite-error-overlay custom element
      const originalDefine = customElements.define;
      customElements.define = function(name, constructor, options) {
        if (name === 'vite-error-overlay') {
          console.log('[App iframe] Blocked vite-error-overlay');
          return;
        }
        return originalDefine.call(this, name, constructor, options);
      };

      // Watch for and remove any vite-error-overlay elements
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeName === 'VITE-ERROR-OVERLAY' || 
                (node.tagName && node.tagName.toLowerCase() === 'vite-error-overlay')) {
              console.log('[App iframe] Removing vite-error-overlay');
              node.remove();
            }
          });
        });
      });
      observer.observe(document.body, { childList: true, subtree: true });

      // Immediately isolate this iframe from parent errors
      window.addEventListener('error', (e) => {
        e.stopPropagation();
        e.preventDefault();
        console.error('[App iframe] window error:', e.error || e.message);
        showOverlay(String(e?.error?.message || e?.message || 'Unknown error'));
        // Forward runtime error to host for automatic diagnostics
        try {
          window.top?.postMessage({
            type: 'APP_RUNTIME_ERROR',
            message: String(e?.error?.message || e?.message || 'Unknown error'),
            stack: String((e?.error && e.error.stack) || ''),
            pathname: location.pathname,
            search: location.search,
            hash: location.hash
          }, '*');
        } catch {}
      }, true);
      
      window.addEventListener('unhandledrejection', (e) => {
        e.stopPropagation();
        e.preventDefault();
        console.error('[App iframe] unhandledrejection:', e.reason);
        showOverlay(String(e?.reason?.message || e?.reason || 'Unhandled promise rejection'));
        // Forward promise rejection to host for automatic diagnostics
        try {
          window.top?.postMessage({
            type: 'APP_RUNTIME_ERROR',
            message: String(e?.reason?.message || e?.reason || 'Unhandled promise rejection'),
            stack: String((e?.reason && e.reason.stack) || ''),
            pathname: location.pathname,
            search: location.search,
            hash: location.hash
          }, '*');
        } catch {}
      }, true);

      // Prevent errors from bubbling to parent
      const originalConsoleError = console.error;
      console.error = function(...args) {
        try {
          originalConsoleError.apply(console, ['[App iframe]', ...args]);
        } catch {}
        // Forward to host for automatic diagnostics
        try {
          const safeArgs = args.map(a => {
            try {
              if (typeof a === 'string') return a;
              if (a && typeof a === 'object') return a.message || JSON.stringify(a).slice(0, 1200);
              return String(a);
            } catch { return '[unserializable]'; }
          });
          window.top?.postMessage({
            type: 'APP_CONSOLE',
            level: 'error',
            args: safeArgs,
            pathname: location.pathname,
            search: location.search,
            hash: location.hash
          }, '*');
        } catch {}
      };

      // Also forward console.warn (lower priority; host may ignore)
      const originalConsoleWarn = console.warn;
      console.warn = function(...args) {
        try { originalConsoleWarn.apply(console, ['[App iframe]', ...args]); } catch {}
        try {
          const safeArgs = args.map(a => {
            try {
              if (typeof a === 'string') return a;
              if (a && typeof a === 'object') return a.message || JSON.stringify(a).slice(0, 800);
              return String(a);
            } catch { return '[unserializable]'; }
          });
          window.top?.postMessage({
            type: 'APP_CONSOLE',
            level: 'warn',
            args: safeArgs,
            pathname: location.pathname,
            search: location.search,
            hash: location.hash
          }, '*');
        } catch {}
      };

      
      import { createRoot } from '/src/iframe-root.js';
      // Hint Vite/Tailwind to include all app entry modules in the module graph
      // so Tailwind v4 can detect their classes even when loaded dynamically.
      const loaders = import.meta.glob('/src/apps/**/index.{tsx,ts,jsx,js}');
      // Expect query: ?path=/src/apps/xxx/index.tsx&name=...&id=...
      const params = new URLSearchParams(location.search)
      const path = params.get('path')
      const name = params.get('name') || 'App'
      const mountEl = document.getElementById('mount')
      
      // Import CSS for styling (always load; URL flags can disable if set to 0)
      // Flags: base=0 (disable index.css), ui=0 (disable desktop/ui), tw=0 (disable tailwind)
      try {
        const loadBase = params.get('base') !== '0'
        const loadUi = params.get('ui') !== '0'
        const loadTw = params.get('tw') !== '0'
        
        // Always load Tailwind first to ensure utilities are available
        if (loadTw) {
          await import('/src/tailwind.css')
          console.log('[App iframe] Tailwind CSS loaded')
        }
        if (loadBase) {
          await import('/src/index.css')
          console.log('[App iframe] Base CSS loaded')
        }
        if (loadUi) {
          await import('/src/desktop/styles.css')
          console.log('[App iframe] Desktop UI CSS loaded')
        }
      } catch (e) {
        console.error('[App iframe] CSS import error:', e)
      }
      
      // Global error isolation inside iframe
      const overlay = document.createElement('div')
      overlay.style.cssText = 'position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(255,255,255,0.85);color:#991b1b;text-align:center;z-index:99999;padding:16px'
      overlay.innerHTML = '<div style="max-width:560px"><div style="font-weight:600;margin-bottom:6px">This app encountered an error</div><div id="errMsg" style="font-size:12px;color:#7f1d1d;white-space:pre-wrap"></div><button id="reloadBtn" style="margin-top:12px;padding:6px 10px;border-radius:6px;border:1px solid #fecaca;background:#fee2e2;color:#7f1d1d">Reload app</button></div>'
      document.body.appendChild(overlay)
      overlay.querySelector('#reloadBtn')?.addEventListener('click', ()=> location.reload())
      
      function showOverlay(msg){
        const el = overlay.querySelector('#errMsg')
        if (el) el.textContent = msg
        overlay.style.display = 'flex'
      }
      if (!path){
        mountEl.textContent = 'Missing app path'
      } else {
        // Wrap everything in try-catch to prevent errors from bubbling up
        try {
          // Load the module and mount default export as a React component
          const load = loaders[path] ? loaders[path] : (p)=> import(/* @vite-ignore */ p);
          Promise.resolve(load(path)).then(mod => {
            try {
              const Comp = mod?.default
              createRoot(mountEl, Comp, name)
            } catch (renderErr) {
              console.error('[App iframe] component render error:', renderErr)
              showOverlay('App render error: ' + renderErr.message)
            }
          }).catch(err => {
            console.error('[App iframe] module load error:', err)
            showOverlay('Failed to load app: ' + err)
          })
        } catch (err) {
          console.error('[App iframe] setup error:', err)
          showOverlay('App setup error: ' + err)
        }
      }

      // HMR anti-flash inside app iframe
      try {
        const mask = document.getElementById('vite-hmr-mask')
        const show = () => { if (mask) { mask.style.opacity = '.9' } }
        const hideSoon = () => { setTimeout(() => { if (mask) mask.style.opacity = '0' }, 120) }
        if (import.meta && import.meta.hot) {
          import.meta.hot.on('vite:beforeUpdate', show)
          import.meta.hot.on('vite:afterUpdate', hideSoon)
          import.meta.hot.on('full-reload', show)
        }
      } catch {}
    </script>
  </body>
  </html>
